<HTML><HEAD><TITLE>OpenGL - Advanced</TITLE></HEAD><BODY><CENTER>

<A HREF="../progs.html"><IMG SRC="../opengl.jpg"></A><BR>

<A HREF="./"><H1>advanced/</H1></A>

<BR><IMG SRC="../divider.gif"><BR>

<BR>
<TABLE BORDER=3 WIDTH=520 CELLPADDING=6>
<TR>
 <TD><IMG SRC="accumaa.jpg"></TD>
 <TD VALIGN=TOP>
  <BR> Using the accumulation buffers to anti-alias a scene.<BR>
  <BR> Source code: <A HREF="accumaa.c">accumaa.c</A>.<BR>
  <BR> Executable: <A HREF="accumaa.exe">accumaa.exe</A>.<BR>
  <BR> Snapshots: <A HREF="accumaa.jpg">anti-aliased (shown)</A>, <A HREF="accumaa1.jpg">aliased</A>.<BR>
 </TD>
</TR>
</TABLE>

<BR>
<TABLE BORDER=3 WIDTH=520 CELLPADDING=6>
<TR>
 <TD><IMG SRC="af_depthcue.jpg"></TD>
 <TD VALIGN=TOP>
  <BR> Adding depthcue (fog) in a second rendering pass.<BR>
  <BR> Source code: <A HREF="af_depthcue.c">af_depthcue.c</A>.<BR>
  <BR> Executable: <A HREF="af_depthcue.exe">af_depthcue.exe</A>.<BR>
  <BR> Snapshots: <A HREF="af_depthcue.jpg">fog added by second pass (shown)</A>, <A HREF="af_depthcue1.jpg">fog rendered normally</A>.<BR>
 </TD>
</TR>
</TABLE>

<BR>
<TABLE BORDER=3 WIDTH=520 CELLPADDING=6>
<TR>
 <TD><IMG SRC="af_teapots.jpg"></TD>
 <TD VALIGN=TOP>
  <BR> More detailed example of adding fog in a second rendering pass.<BR>
  <BR> Source code: <A HREF="af_teapots.c">af_teapots.c</A>.<BR>
  <BR> Executable: <A HREF="af_teapots.exe">af_teapots.exe</A>.<BR>
  <BR> Snapshots: <A HREF="af_teapots.jpg">linear fog (shown)</A>, <A HREF="af_teapots1.jpg">linear fog added by second pass</A>.<BR>
 </TD>
</TR>
</TABLE>

<BR>
<TABLE BORDER=3 WIDTH=520 CELLPADDING=6>
<TR>
 <TD><IMG SRC="convolve.jpg"></TD>
 <TD VALIGN=TOP>
  <BR> Using the accumulation buffer for fast convolutions.<BR>
  <BR> Source code: <A HREF="convolve.c">convolve.c</A>.<BR>
  <BR> Executable: <A HREF="convolve.exe">convolve.exe</A>.<BR>
  <BR> Snapshots: <A HREF="convolve.jpg">5x5 blur (shown)</A>, <A HREF="convolve1.jpg">laplace transform</A>.<BR>
 </TD>
</TR>
</TABLE>

<BR>
<TABLE BORDER=3 WIDTH=520 CELLPADDING=6>
<TR>
 <TD><IMG SRC="boundary.jpg"></TD>
 <TD VALIGN=TOP>
  <BR>
   This example shows how to use the GLU polygon tessellator to determine the 
   2D boundary of OpenGL rendered objects.  The program uses OpenGL's
   feedback mechanim to capture transformed polygons and then feeds them to
   the GLU tesselator in GLU_TESS_WINDING_NONZERO and GLU_TESS_BOUNDARY_ONLY
   mode.
  <BR>
  <BR> Source code: <A HREF="boundary.c">boundary.c</A>.<BR>
  <BR> Executable: <A HREF="boundary.exe">boundary.exe</A>.<BR>
  <BR> Snapshots: <A HREF="boundary.jpg">torus (shown)</A>.<BR>
 </TD>
</TR>
</TABLE>

<BR>
<TABLE BORDER=3 WIDTH=520 CELLPADDING=6>
<TR>
 <TD><IMG SRC="csg.jpg"></TD>
 <TD VALIGN=TOP>
  <BR> Composite solid geometry using the stencil buffer.<BR>
  <BR> Source code: <A HREF="csg.c">csg.c</A>.<BR>
  <BR> Executable: <A HREF="csg.exe">csg.exe</A>.<BR>
  <BR> Snapshots: <A HREF="csg.jpg">A or B (shown)</A>, <A HREF="csg1.jpg">A sub B</A>.<BR>
 </TD>
</TR>
</TABLE>

<BR>
<TABLE BORDER=3 WIDTH=520 CELLPADDING=6>
<TR>
 <TD><IMG SRC="decal.jpg"></TD>
 <TD VALIGN=TOP>
  <BR> Decaling the letter "T" using the stencil buffer.<BR>
  <BR> Source code: <A HREF="decal.c">decal.c</A>.<BR>
  <BR> Executable: <A HREF="decal.exe">decal.exe</A>.<BR>
  <BR> Snapshots: <A HREF="decal.jpg">T decal(shown)</A>.<BR>
 </TD>
</TR>
</TABLE>

<BR>
<TABLE BORDER=3 WIDTH=520 CELLPADDING=6>
<TR>
 <TD><IMG SRC="dissolve.jpg"></TD>
 <TD VALIGN=TOP>
  <BR> Dissolving using the stencil buffer.<BR>
  <BR> Source code: <A HREF="dissolve.c">dissolve.c</A>.<BR>
  <BR> Executable: <A HREF="dissolve.exe">dissolve.exe</A>.<BR>
  <BR> Snapshots: <A HREF="dissolve.jpg">dissolved checkerboard (shown)</A>.<BR>
 </TD>
</TR>
</TABLE>

<BR>
<TABLE BORDER=3 WIDTH=520 CELLPADDING=6>
<TR>
 <TD><IMG SRC="envphong.jpg"></TD>
 <TD VALIGN=TOP>
  <BR> Demonstrates a use of environment texture mapping for improved highlight shading.<BR>
  <BR> Source code: <A HREF="envphong.c">envphong.c</A>.<BR>
  <BR> Executable: <A HREF="envphong.exe">envphong.exe</A>.<BR>
  <BR> Snapshots: <A HREF="envphong.jpg">sphere (shown)</A>, <A HREF="envphong1.jpg">checkerboard torus</A>.<BR>
 </TD>
</TR>
</TABLE>

<BR>
<TABLE BORDER=3 WIDTH=520 CELLPADDING=6>
<TR>
 <TD><IMG SRC="field.jpg"></TD>
 <TD VALIGN=TOP>
  <BR> Using the accumulation buffer for depth of field (camera focus blur).<BR>
  <BR> Source code: <A HREF="field.c">field.c</A>.<BR>
  <BR> Executable: <A HREF="field.exe">field.exe</A>.<BR>
  <BR> Snapshots: <A HREF="field.jpg">depth of field(shown)</A>, <A HREF="field1.jpg">normal</A>.<BR>
 </TD>
</TR>
</TABLE>

<BR>
<TABLE BORDER=3 WIDTH=520 CELLPADDING=6>
<TR>
 <TD><IMG SRC="genmipmap.jpg"></TD>
 <TD VALIGN=TOP>
  <BR> Example of how to generate texture mipmap levels with the accumulation buffer.<BR>
  <BR> Source code: <A HREF="genmipmap.c">genmipmap.c</A>.<BR>
  <BR> Executable: <A HREF="genmipmap.exe">genmipmap.exe</A>.<BR>
  <BR> Snapshots: <A HREF="genmipmap.jpg">mandrill mipmap (shown)</A>.<BR>
 </TD>
</TR>
</TABLE>

<BR>
<TABLE BORDER=3 WIDTH=520 CELLPADDING=6>
<TR>
 <TD><IMG SRC="haloed.jpg"></TD>
 <TD VALIGN=TOP>
  <BR> Draw haloed lines using the stencil buffer.<BR>
  <BR> Source code: <A HREF="haloed.c">haloed.c</A>.<BR>
  <BR> Executable: <A HREF="haloed.exe">haloed.exe</A>.<BR>
  <BR> Snapshots: <A HREF="haloed.jpg">torus (shown)</A>.<BR>
 </TD>
</TR>
</TABLE>

<BR>
<TABLE BORDER=3 WIDTH=520 CELLPADDING=6>
<TR>
 <TD><IMG SRC="hello2rts.jpg"></TD>
 <TD VALIGN=TOP>
  <BR> Demonstrates a method of generating real-time shadows.<BR>
  <BR> Source code: <A HREF="hello2rts.c">hello2rts.c</A>, <A HREF="rts.c">rts.c</A>, <A HREF="rtshadow.h">rtshadow.h</A>.<BR>
  <BR> Executable: <A HREF="hello2rts.exe">hello2rts.exe</A>.<BR>
  <BR> Snapshots: <A HREF="hello2rts.jpg">scene (shown)</A>.<BR>
 </TD>
</TR>
</TABLE>

<BR>
<TABLE BORDER=3 WIDTH=520 CELLPADDING=6>
<TR>
 <TD><IMG SRC="hiddenline.jpg"></TD>
 <TD VALIGN=TOP>
  <BR> Line Rendering: Hidden line techniques.<BR>
  <BR> Source code: <A HREF="hiddenline.c">hiddenline.c</A>.<BR>
  <BR> Executable: <A HREF="hiddenline.exe">hiddenline.exe</A>.<BR>
  <BR> Snapshots: <A HREF="hiddenline.jpg">fat lines (shown)</A>.<BR>
 </TD>
</TR>
</TABLE>

<BR>
<TABLE BORDER=3 WIDTH=520 CELLPADDING=6>
<TR>
 <TD><IMG SRC="imgproc.jpg"></TD>
 <TD VALIGN=TOP>
  <BR> Examples of various image processing operations coded as OpenGL
   accumulation buffer operations.<BR>
  <BR> Source code: <A HREF="imgproc.c">imgproc.c</A>.<BR>
  <BR> Executable: <A HREF="imgproc.exe">imgproc.exe</A>.<BR>
  <BR> Snapshots: <A HREF="imgproc.jpg">saturated (shown)</A>.<BR>
 </TD>
</TR>
</TABLE>

<BR>
<TABLE BORDER=3 WIDTH=520 CELLPADDING=6>
<TR>
 <TD><IMG SRC="mipmap_lines.jpg"></TD>
 <TD VALIGN=TOP>
  <BR> Survey of different mipmap filters.<BR>
  <BR> Source code: <A HREF="mipmap_lines.c">mipmap_lines.c</A>.<BR>
  <BR> Executable: <A HREF="mipmap_lines.exe">mipmap_lines.exe</A>.<BR>
  <BR> Snapshots: <A HREF="mipmap_lines.jpg">GLU mipmaps on the left, MITCHELL mipmaps on the right (shown)</A>.<BR>
 </TD>
</TR>
</TABLE>

<BR>
<TABLE BORDER=3 WIDTH=520 CELLPADDING=6>
<TR>
 <TD><IMG SRC="motionblur.jpg"></TD>
 <TD VALIGN=TOP>
  <BR> Using the accumulation buffer for motion blur.<BR>
  <BR> Source code: <A HREF="motionblur.c">motionblur.c</A>.<BR>
  <BR> Executable: <A HREF="motionblur.exe">motionblur.exe</A>.<BR>
  <BR> Snapshots: <A HREF="motionblur.jpg">motion (shown)</A>, <A HREF="motionblur1.jpg">normal</A>.<BR>
 </TD>
</TR>
</TABLE>

<BR>
<TABLE BORDER=3 WIDTH=520 CELLPADDING=6>
<TR>
 <TD><IMG SRC="multilight.jpg"></TD>
 <TD VALIGN=TOP>
  <BR> 
   This program demonstrates virtualization of OpenGL's lights.  The idea is
   that if an object is lit by many lights, it is computationally more
   efficient to calculate the approximate lighting contribution of the
   various lights per-object and only enable the "brightest" lights while
   rendering the object.  This also lets you render scenes with more lights
   than the OpenGL implementation light (usually 8).  Two approaches are
   used:  The "distance-based" approach only enables the 8 closest lights
   based purely on distance.  The "Lambertian-based" approach accounts for
   diffuse lighting contributions and approximates the diffuse contribution.
  <BR>
  <BR> Source code: <A HREF="multilight.c">multilight.c</A>.<BR>
  <BR> Executable: <A HREF="multilight.exe">multilight.exe</A>.<BR>
  <BR> Snapshots: <A HREF="multilight.jpg">scene (shown)</A>.<BR>
 </TD>
</TR>
</TABLE>

<BR>
<TABLE BORDER=3 WIDTH=520 CELLPADDING=6>
<TR>
 <TD><IMG SRC="projshadow.jpg"></TD>
 <TD VALIGN=TOP>
  <BR> Rendering shadows using projective transforms.<BR>
  <BR> Source code: <A HREF="projshadow.c">projshadow.c</A>.<BR>
  <BR> Executable: <A HREF="projshadow.exe">projshadow.exe</A>.<BR>
  <BR> Snapshots: <A HREF="projshadow.jpg">shadows (shown)</A>, <A HREF="projshadow1.jpg">no shadows</A>.<BR>
 </TD>
</TR>
</TABLE>

<BR>
<TABLE BORDER=3 WIDTH=520 CELLPADDING=6>
<TR>
 <TD><IMG SRC="projtex.jpg"></TD>
 <TD VALIGN=TOP>
  <BR> Demonstrates simple projective texture mapping.<BR>
  <BR> Source code: <A HREF="projtex.c">projtex.c</A>.<BR>
  <BR> Executable: <A HREF="projtex.exe">projtex.exe</A>.<BR>
  <BR> Snapshots: <A HREF="projtex.jpg">cube (shown)</A>, <A HREF="projtex1.jpg">three sides</A>.<BR>
 </TD>
</TR>
</TABLE>

<BR>
<TABLE BORDER=3 WIDTH=520 CELLPADDING=6>
<TR>
 <TD><IMG SRC="rasonly.jpg"></TD>
 <TD VALIGN=TOP>
  <BR> Demonstrates the use of OpenGL for rasterization-only, with
perspective-correct texture mapping.<BR>
  <BR> Source code: <A HREF="rasonly.c">rasonly.c</A>.<BR>
  <BR> Executable: <A HREF="rasonly.exe">rasonly.exe</A>.<BR>
  <BR> Snapshots: <A HREF="rasonly.jpg">textured plane (shown)</A>.<BR>
 </TD>
</TR>
</TABLE>

<BR>
<TABLE BORDER=3 WIDTH=520 CELLPADDING=6>
<TR>
 <TD><IMG SRC="shadowfun.jpg"></TD>
 <TD VALIGN=TOP>
  <BR> This program demonstrates a light source and object of arbitrary geometry casing a shadow on arbitary geometry.  The program uses OpenGL's feedback, stencil, and boundary tessellation support. <BR>
  <BR> Source code: <A HREF="shadowfun.c">shadowfun.c</A>.<BR>
  <BR> Executable: <A HREF="shadowfun.exe">shadowfun.exe</A>.<BR>
  <BR> Snapshots: <A HREF="shadowfun.jpg">shadows (shown)</A>, <A HREF="shadowfun1.jpg">view from light</A>.<BR>
 </TD>
</TR>
</TABLE>

<BR>
<TABLE BORDER=3 WIDTH=520 CELLPADDING=6>
<TR>
 <TD><IMG SRC="shadowvol.jpg"></TD>
 <TD VALIGN=TOP>
  <BR> Demonstrate shadow volume techniques.<BR>
  <BR> Source code: <A HREF="shadowvol.c">shadowvol.c</A>.<BR>
  <BR> Executable: <A HREF="shadowvol.exe">shadowvol.exe</A>.<BR>
  <BR> Snapshots: <A HREF="shadowvol.jpg">shadow (shown)</A>, <A HREF="shadowvol1.jpg">volume</A>.<BR>
 </TD>
</TR>
</TABLE>

<BR>
<TABLE BORDER=3 WIDTH=520 CELLPADDING=6>
<TR>
 <TD><IMG SRC="silhouette.jpg"></TD>
 <TD VALIGN=TOP>
  <BR> Generating silhouette edges with the stencil buffer.<BR>
  <BR> Source code: <A HREF="silhouette.c">silhouette.c</A>.<BR>
  <BR> Executable: <A HREF="silhouette.exe">silhouette.exe</A>.<BR>
  <BR> Snapshots: <A HREF="silhouette.jpg">torus (shown)</A>.<BR>
 </TD>
</TR>
</TABLE>

<BR>
<TABLE BORDER=3 WIDTH=520 CELLPADDING=6>
<TR>
 <TD><IMG SRC="softshadow.jpg"></TD>
 <TD VALIGN=TOP>
  <BR> Demonstrate the use of accumulation buffer to create soft shadows.<BR>
  <BR> Source code: <A HREF="softshadow.c">softshadow.c</A>.<BR>
  <BR> Executable: <A HREF="softshadow.exe">softshadow.exe</A>.<BR>
  <BR> Snapshots: <A HREF="softshadow.jpg">soft shadows (shown)</A>, <A HREF="softshadow1.jpg">no shadows</A>.<BR>
 </TD>
</TR>
</TABLE>

<BR>
<TABLE BORDER=3 WIDTH=520 CELLPADDING=6>
<TR>
 <TD><IMG SRC="tess.jpg"></TD>
 <TD VALIGN=TOP>
  <BR> Different tesselations for a spherical shape.<BR>
  <BR> Source code: <A HREF="tess.c">tess.c</A>.<BR>
  <BR> Executable: <A HREF="tess.exe">tess.exe</A>.<BR>
  <BR> Snapshots: <A HREF="tess.jpg">geodesic (shown)</A>, <A HREF="tess1.jpg">longitude/lattitude</A>.<BR>
 </TD>
</TR>
</TABLE>

<BR>
<TABLE BORDER=3 WIDTH=520 CELLPADDING=6>
<TR>
 <TD><IMG SRC="textile.jpg"></TD>
 <TD VALIGN=TOP>
  <BR> Demonstration of how to "tile" together small textures with a result identical to if a much larger texture was drawn.<BR>
  <BR> Source code: <A HREF="textile.c">textile.c</A>.<BR>
  <BR> Executable: <A HREF="textile.exe">textile.exe</A>.<BR>
  <BR> Snapshots: <A HREF="textile.jpg">tiled (w/o borders) (shown)</A>.<BR>
 </TD>
</TR>
</TABLE>

<BR>
<TABLE BORDER=3 WIDTH=520 CELLPADDING=6>
<TR>
 <TD><IMG SRC="textrim.jpg"></TD>
 <TD VALIGN=TOP>
  <BR> Trimming textures: demonstrates how alpha blending or alpha testing
   can be used to "trim" the shape of textures to arbitrary shapes.<BR>
  <BR> Source code: <A HREF="textrim.c">textrim.c</A>.<BR>
  <BR> Executable: <A HREF="textrim.exe">textrim.exe</A>.<BR>
  <BR> Snapshots: <A HREF="textrim.jpg">alpha tested (shown)</A>, <A HREF="textrim1.jpg">no alpha blending/testing</A>.<BR>
 </TD>
</TR>
</TABLE>

<BR>
<TABLE BORDER=3 WIDTH=520 CELLPADDING=6>
<TR>
 <TD><IMG SRC="tvertex.jpg"></TD>
 <TD VALIGN=TOP>
  <BR> T-vertex artifacts example.  The moral: Avoid vertex edge
junctions that make a T-shape.<BR>
  <BR> Source code: <A HREF="tvertex.c">tvertex.c</A>.<BR>
  <BR> Executable: <A HREF="tvertex.exe">tvertex.exe</A>.<BR>
  <BR> Snapshots: <A HREF="tvertex.jpg">shaded T artifact (shown)</A>, <A HREF="tvertex1.jpg">wireframe</A>.<BR>
 </TD>
</TR>
</TABLE>

<BR>
<TABLE BORDER=3 WIDTH=520 CELLPADDING=6>
<TR>
 <TD><IMG SRC="warp.jpg"></TD>
 <TD VALIGN=TOP>
  <BR> Image warping operations can be done via OpenGL texture mapping.<BR>
  <BR> Source code: <A HREF="warp.c">warp.c</A>.<BR>
  <BR> Executable: <A HREF="warp.exe">warp.exe</A>.<BR>
  <BR> Snapshots: <A HREF="warp.jpg">warped mandrill (shown)</A>.<BR>
 </TD>
</TR>
</TABLE>

<BR>
<TABLE BORDER=3 WIDTH=520 CELLPADDING=6>
<TR>
 <TD><IMG SRC="zcomposite.jpg"></TD>
 <TD VALIGN=TOP>
  <BR> Compositing images that include depth information.<BR>
  <BR> Source code: <A HREF="zcomposite.c">zcomposite.c</A>.<BR>
  <BR> Executable: <A HREF="zcomposite.exe">zcomposite.exe</A>.<BR>
  <BR> Snapshots: <A HREF="zcomposite.jpg">composited scene (shown)</A>.<BR>
 </TD>
</TR>
</TABLE>

<BR><IMG SRC="../divider.gif"><BR>

<H5>Copyright &copy; 1997 Silicon Graphics Incorporated.</H5>

</CENTER></BODY></HTML>
